/*In order to send the value to inner, I redefined the number Zero to Six*/
declare Zero=
fun{$ Y}
   fun{$ X}
   Y
   end
end

/* Succ function should break Y first and  nest it again*/ 
declare Succ=
fun{$ N}
   fun{$ Y}
   fun {$ X}
     {N Y}
   end
 end
end

declare One={Succ Zero}
declare Two={Succ One}
declare Three={Succ Two}
declare Four={Succ Three}
declare Five={Succ Four}
declare Six={Succ Five}
declare IsZero?=
fun {$ N}
 {Not {IsProcedure {{N true}true}}}/*because the Zero is two levels function,so N should break two times*/
end


declare Pred=
fun {$ N}
   fun{$ Y}
      {{N Y}Zero}
   end
end

declare LambdaNumber=
fun {$ N}
   if {IsZero N}then
      0
   else
      1+{LambdaNumber {Pred N}}
   end
end
/*M and N is the input*//*because I defined zero has two levels nestifications, so the first Y value uses to break first nestification of N, second Y can be substituted by any defined value,in order to break another nestification of N because M N are generated by Zero, so if we want to add them together, the Zero is cauculated twice,so the nestifications should be subtracted by one */
declare Add=
fun{$ M}
   fun{$ N}
      fun {$ Y}
	 {M {{N Y}Y}}
      end
   end
end
{Browse {LambdaNumber {{Add Six}Six}}}

